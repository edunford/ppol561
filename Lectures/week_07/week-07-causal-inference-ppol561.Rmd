---
title: 
    <font class = "title-panel"> PPOL561 | Accelerated Statistics for Public Policy II</font>
  <font size=6, face="bold"> Week 7 </font> 
  <br>
  <br>
  <font size=100, face="bold"> Introduction to Causal Inference </font>
author: 
  <font class = "title-footer"> 
  &emsp;Prof. Eric Dunford &emsp;&#9670;&emsp; Georgetown University &emsp;&#9670;&emsp; McCourt School of Public Policy &emsp;&#9670;&emsp; eric.dunford@georgetown.edu</font>
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: "gu-theme.css"
    nature:
      beforeInit: "macros.js"
      highlightStyle: github
      countIncrementalSlides: false
      highlightLines: true
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T,message=F,error=F,warning = F,cache = T)
require(tidyverse)
library(dagitty)
library(ggdag)

theme_set(theme_dag())
```

layout: true

<div class="slide-footer"><span> 
PPOL561 | Accelerated Statistics for Public Policy II

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;

Week 7 <!-- Week of the Footer Here -->

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;

Introduction to Causal Inference <!-- Title of the lecture here -->

</span></div> 

---
class: outline

# Outline for Today 

![:space 1]

- **Causal Inference**

![:space 3]

- **Structural Causal Models**

  + **_DAGs_**
  
  + **_Interventions_** and **_Adjustments_**
  
  + **_Causal Discovery_**

![:space 3]

- **Potential Outcomes**

---

class: newsection

# Causal Inference


---

## Inference

![:space 2]

We're interested in two types of inference:

![:space 2]  

- **Descriptive Inference**: seeks to describe the existence of something or some process.

![:space 2]  
  
- **Causal Inference**: seeks to understand the effect of one variable on the other.

![:space 3]

The aim is to use information retrieved from a **_sample_** to make inferences about the state of the world _outside_ the sample (i.e. generalize to the population).


---

### Causal Effects 

![:space 1]

- A **_causal effect_** is the difference between what happens to a unit after it received some treatment and what would have happened given it never received the treatment.

![:space 2]

- A causal effect is a **_theoretical quantity_** defined independently of any empirical method that might be used to estimate it from real data.


![:space 3]

- Through a clear research design and modeling strategy we aim to **_infer_** the causal relationship between treatment and outcome. 

![:space 3]

- **_Identifying the causal process is separate from the parametric models_** that we use to estimate a causal effect.


---

### Frameworks for identifying causal effects

We'll explore two prominent frameworks used in the causal inference literature.

- **Structural Causal Models** (DAGs)

  - Champion(s): _Judea Pearl_ (Computer Science)
  - Applications to Artificial Intelligence 
  - Useful when thinking about the causal structure (causal mechanism) and when attempting to isolate causal effects from observational data.
  
- **_Potential Outcomes_**

  - Champion(s): _Guido Imbens_ (Economics) & _Donald Rubin_ (Statistics)
  - Applications to the social sciences.
  - Useful when thinking about treatment (interventions) and random assignment mechanisms (experiments, quasi-experiments)


---

class: newsection

# Structural Causal Models

---

## Directed Acyclical Graphs (DAGs)

- A DAG is a way of **_modeling a causal effect using graphs_**. The DAG represents these causal effects through a set of **_nodes_** and **_arrows_** (directed edges)

  - **_nodes_** represent random variables. 
  - **_edges_** represent a _causal effect_.
  - The direction of the arrow captures **_cause_** and **_effect_**

```{r,echo=F,fig.width=10,fig.height=3.5,fig.align='center',dpi=200}
coords <- 
  c("x",0,.5,
    "z",0,1,
    "u",1.5,1,
    "y",2,.5) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}


# Initialize the DAG.
dag <- dagify(x ~ z,
              y ~ z,
              z ~ u,
              y ~ x + u,
              exposure = "x",
              outcome = "y",
              coords=coords)

ggdag(dag,text_size = 8)
```

---

## Where do DAGs come from?

![:space 2]

- **_DAGs are generated from_**: 
  - domain expertise;
  - theory and existing models;
  - intuition and/or common knowledge; 
  - data (more on this later).

- **_DAGs are useful for_**:

  - Causal identification using observable data;
  - Developing research designs;
  - Matching theoretical arguments to empirical modeling strategy.
  
- Ultimately, DAGs are models of how we think the **_world works_**.

---

![:space 5]

A causal effect can either be **_direct_**.

```{r,echo=F,fig.width=7,fig.height=2,fig.align='center',dpi=200}
# Simple DAG
coords <- data.frame(matrix(c("x",0,0,
                              "y",2,0), nrow=2, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")

# Initialize the DAG.
dag <- dagify(y ~ x,
              exposure = "x",
              outcome = "y",
              coords=coords)
ggdag(dag,text_size = 8)
```


Or a causal effect can be **_mediated_** by a third variable.

```{r,echo=F,fig.width=7,fig.height=2,fig.align='center',dpi=200}
# Simple DAG
coords <- data.frame(matrix(c("x",0,0,
                              "z",1,0,
                              "y",2,0), nrow=3, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")

# Initialize the DAG.
dag <- dagify(z ~ x,
              y ~ z,
              exposure = "x",
              outcome = "y",
              coords=coords)
ggdag(dag,text_size = 6) 
```

---

![:space 5]

We denote dependencies due to an **_omitted common cause_** using dashed edges.

Edges can be expressed either as bidirectional edge or as a greyed out node.

```{r,echo=F,fig.width=8.5,fig.height=4,fig.align='center',dpi=200}
coords <- 
  c("x",0,0,
    "z",0,1,
    "u",1.5,1,
    "y",2,0) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}


# Initialize the DAG.
dag <- dagify(x ~ z,
              y ~ z,
              z ~ u,
              y ~ x + u,
              exposure = "x",
              outcome = "y",
              coords=coords)


dag %>% 
  tidy_dagitty() %>% 
  mutate(observed = ifelse(name=="u",2,1)) %>% 
  mutate(observed_text = ifelse(name=="u","black","white")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed)) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F) +
  scale_color_manual(values=c('1'="black",'2'="grey80")) +
  geom_dag_text(size = 8) +
  theme_dag()
```


---

We use **_kinship terminology_** when referencing relationships between nodes.


```{r,echo=F,fig.width=7,fig.height=4.25,fig.align='center',dpi=200}
dag <- dagify(X ~ Z + U,
              Z ~ P,
              Y ~ Z,
              Y ~ X,
              exposure = "X",
              outcome = "Y") 
d = dag %>% tidy_dagitty(seed=123) 

ggdag(d)
```

---

![:space 3]

```{r,echo=F,fig.width=7,fig.height=4.5,fig.align='center',dpi=200}

ggdag_parents(d,"Y") +
  scale_color_manual(values=c("black","steelblue")) +
  labs(color="") +
  theme(legend.position = "top")

```

---

![:space 3]

```{r,echo=F,fig.width=7,fig.height=4.5,fig.align='center',dpi=200}
ggdag_ancestors(d,"Y") +
  scale_color_manual(values=c("steelblue","black")) +
  labs(color="") +
  theme(legend.position = "top")
```

---

A **_path_** is a sequence of edges that connect two variables (vertices).

- A path can go either along or against the direction of the edges. (e.g. below are the paths from P to Y in the previous graph)

```{r,echo=F,fig.width=7,fig.height=4.25,fig.align='center',dpi=200}
ggdag_paths(d,from="P",to="Y",shadow = T) +
  theme(legend.position = "none",
        strip.text = element_blank()) 
```


---

![:space 3]

- Causal relationships in a DAG are **_asymmetric_**
    
  + If "X causes B" is true, then "Y causes X" must be false. 
  
- There are **_no cycles_**, **_feedback loops_**, or **_simultaneous effects_** in a DAG.

- But concepts like **_reverse causality_** can be modeled using time indices.


```{r,echo=F,fig.width=9,fig.height=3.5,fig.align='center',dpi=200}
coords <- 
  c("y_t1",0,0,
    "x_t1",0,1,
    "x_t2",1,1,
    "y_t2",1,0,
    "x_t3",2,1,
    "y_t3",2,0) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}

dag <- dagify(y_t1 ~ x_t1,
              x_t2 ~ y_t1,
              y_t2 ~ x_t2,
              x_t3 ~ y_t2,
              y_t3 ~ x_t3,
              exposure = "x_t2",
              outcome = "y_t2",
              coords=coords)
dag %>% 
  tidy_dagitty() %>% 
  arrange(name) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point() +
  geom_dag_edges() +
  geom_dag_text(size=6,parse = TRUE, label = c(expression(X[t-1]), 
                                        expression(X[t]),
                                        expression(X[t+1]),
                                        expression(Y[t-1]),
                                        expression(Y[t]),
                                        expression(Y[t+1]))) +
  theme_dag()
```

---

- The aim of a DAG is to represent some underlying **_structural causal model_**. 

- The framework is fully **_non-parametric_**, meaning the structural model makes no functional form assumptions.

- $f_i()$ represents any arbitrary function, and $\epsilon_i$ represents disturbances.

.pull-left[

```{r,echo=F,fig.width=4,fig.height=3.5,fig.align='center',dpi=200}
coords <- 
  c("X",0,.5,
    "Z",0,1,
    "Y",2,.5) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}


# Initialize the DAG.
dag <- dagify(X ~ Z,
              Y ~ Z,
              Y ~ X,
              exposure = "X",
              outcome = "Y",
              coords=coords)

ggdag(dag,text_size = 8)
```
]

.pull-right[

<br>

- $Z = f_1(\epsilon_1)$

- $X = f_2(Z,\epsilon_2)$

- $Y = f_3(Z,X,\epsilon_3)$

]

---

![:space 7]

A DAG is meant to be a **_complete description_** of all causal relationships of some phenomena. 

![:space 1]

The graph holds information on **_conditional independence relationships_**.  Conditional independence can be inferred from the topology of the graph. 

![:space 1]

There are three topological structures in a DAG to pay attention to when examining for conditional independence:

- **_Chains_**

- **_Forks_**

- **_Colliders_**

---


![:space 10]

**Chains**

$X$ becomes independent of $Y$ conditioning on (controlling for) $Z$ (the mediating variable) 


![:space 10]

```{r,echo=F,fig.width=8,fig.height=1,fig.align='center',dpi=200}
coords <- data.frame(matrix(c("x",0,0,
                              "z",1,0,
                              "y",2,0), nrow=3, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")

dag <- dagify(z ~ x,
              y ~ z,
              exposure = "x",
              outcome = "y",
              coords=coords)
ggdag(dag,text_size = 8) 
```


---


```{r}
set.seed(123)
N <- 1000
x <- rnorm(N)
z <- x + rnorm(N)
y <-  z + rnorm(N)

lm(y ~ x) %>% broom::tidy()
```

```{r}
lm(y ~ x + z) %>% broom::tidy()
```


---

![:space 10]

**Forks**

X and Y are dependent, but becomes independent when conditioning on (controlling for) $Z$.


```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
coords <- data.frame(matrix(c("x",0,0,
                              "z",1,1,
                              "y",2,0), nrow=3, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")

dag <- dagify(x ~ z,
              y ~ z,
              exposure = "x",
              outcome = "y",
              coords=coords)
ggdag(dag,text_size = 8) 
```


---

```{r}
set.seed(123)
N <- 1000
z <- rnorm(N)
x <- z + rnorm(N)
y <-  z + rnorm(N)

lm(y ~ x) %>% broom::tidy()
```

```{r}
lm(y ~ x + z) %>% broom::tidy()
```


---

![:space 10]

**Colliders**

If $Z$ is a collider, $X$ and $Y$ are unconditionally _independent_. However, if we condition on $Z$, $X$ and $Y$ become dependent. That is, conditioning on a collider opens a pathway between $X$ and $Y$. 



```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
coords <- data.frame(matrix(c("x",0,1,
                              "z",1,0,
                              "y",2,1), nrow=3, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")

dag <- dagify(z ~ x,
              z ~ y,
              exposure = "x",
              outcome = "y",
              coords=coords)
ggdag(dag,text_size = 8) 
```


---

![:space 10]

**Colliders**

If $Z$ is a collider, $X$ and $Y$ are unconditionally _independent_. However, if we condition on $Z$, $X$ and $Y$ become dependent. That is, conditioning on a collider opens a pathway between $X$ and $Y$.

```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
dag %>%  
  ggdag_adjust("z",text_size=8) +  
  scale_color_manual(values=c("steelblue","black")) +
  theme(legend.position = "none",
        strip.text = element_blank())
```


---

```{r}
set.seed(1234)
N <- 1000
x <- rnorm(N)
y <- rnorm(N)
z <- x + y + rnorm(N)
lm(y ~ x) %>% broom::tidy()
```

```{r}
lm(y ~ x + z) %>% broom::tidy()
```

---

**_Collider bias_** can be due to _selection issues_ (e.g. talent and beauty example from the reading) and/or conditioning on post-treatment variables. 

DAGs offer us a way to examine if throwing in a specific control variable into a model might _make matters worse_.

--

```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
m_bias() %>% ggdag()
```

---

**_Collider bias_** can be due to _selection issues_ (e.g. talent and beauty example from the reading) and/or conditioning on post-treatment variables. 

DAGs offer us a way to examine if throwing in a specific control variable into a model might _make matters worse_.

```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
m_bias() %>% 
  ggdag_adjust("m") +
  scale_color_manual(values=c("steelblue","black")) +
  theme(legend.position = "none",
        strip.text = element_blank())
```

---

```{r}
set.seed(2222)
N <- 1000
a <- rnorm(N)
b <- rnorm(N)
m <- a + b + rnorm(N)
x <- a + rnorm(N)
y <- b + rnorm(N)

lm(y ~ x) %>% broom::tidy()
```

```{r}
lm(y ~ x + m) %>% broom::tidy()
```


---

![:space 5]

Finally, note that **_collider bias_** can occur even one controls on a **_collider's descendant!_**

```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
# Layout
coords <- data.frame(matrix(c("a",0,1,
                              "b",2,1,
                              "m",1,.5,
                              "x",0,0,
                              "y",2,0,
                              "z",1,0), nrow=6, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")


# Initialize the DAG.
dag <- dagify(x~ a, 
              m ~ a + b,
              z ~ m,
              y ~ b,
              exposure = "x",
              outcome = "y",
              coords=coords)

dag %>% ggdag()
```

---

![:space 5]

Finally, note that **_collider bias_** can occur even one controls on a **_collider's descendant!_**

```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
dag %>% 
  ggdag_adjust('z') +
  scale_color_manual(values=c("steelblue","black")) +
  theme(legend.position = "none",
        strip.text = element_blank())
```

---

```{r}
set.seed(2222)
N <- 1000
a <- rnorm(N)
b <- rnorm(N)
m <- a + b + rnorm(N)
z <- m + rnorm(N)
x <- a + rnorm(N)
y <- b + rnorm(N)

lm(y ~ x) %>% broom::tidy()
```

```{r}
lm(y ~ x + z) %>% broom::tidy()
```


---

## D-Separation

We say that two variables (nodes) are "d-separated" if _every_ path between them is blocked. 

```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
dag <- dagify(X ~ Z + U,
              Z ~ P,
              Y ~ X + Z + U,
              exposure = "X",
              outcome = "Y") 

d = dag %>% tidy_dagitty(seed=123) 

ggdag(d)
```

---

## D-Separation

We say that two variables (nodes) are "d-separated" if _every_ path between them is blocked. 

```{r,echo=F,fig.width=8,fig.height=4,fig.align='center',dpi=200}
ggdag_adjustment_set(d) + 
  labs(color="",shape="") +
  scale_color_manual(values=c("steelblue","black")) +
  theme(legend.position = "none",
        strip.text = element_blank())
```

  
---

## Interventions

![:space 5]

Most questions we ask in economics, public policy, and political science are concerned with specific **_interventions_** that one can impose to alter the status quo.

--

![:space 3]

For DAGs, interventions  are formalize through the **"_do_-operator"**. 

  - If we do this, say set $X= x$, where $x$ is a specific value in the possible range of $x$, how will the probability distribution of $Y$ (our outcome) change. 
  
  - Formally, 
  
$$P(Y | do(X = x))$$
---

## Interventions

![:space 5]

Most questions we ask in economics, public policy, and political science are concerned with specific **_interventions_** that one can impose to alter the status quo.

![:space 3]

- $Pr$(Recurrence of Civil War | do(Peace Keepers))

- $Pr$(Water Quality | do(Environmental Laws))

- $Pr$(Wage | do(Masters Degree))

- $Pr$(Democracy | do(Support Opposition))


---

## Interventions

![:space 10]

.pull-left[
```{r,echo=F,fig.width=5,fig.height=4,fig.align='center',dpi=200}
coords <- data.frame(matrix(c("X",0,0,
                              "Z",1,1,
                              "Y",2,0), nrow=3, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")

dag <- dagify(X ~ Z,
              Y ~ Z,
              Y ~ X,
              exposure = "X",
              outcome = "Y",
              coords=coords)
ggdag(dag,text_size = 8) 
```
]

.pull-right[

<br><br>

- $Z = f_1(\epsilon_1)$

- $X = f_2(Z,\epsilon_2)$

- $Y = f_3(Z,X,\epsilon_3)$

]


---

## Interventions

![:space 10]

.pull-left[
```{r,echo=F,fig.width=5,fig.height=4,fig.align='center',dpi=200}
coords <- data.frame(matrix(c("X",0,0,
                              "x",0,.5,
                              "Z",1,1,
                              "Y",2,0), nrow=4, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")

dag <- dagify(Y ~ Z,
              X ~ x,
              Y ~ X,
              exposure = "X",
              outcome = "Y",
              coords=coords)
ggdag(dag,text_size = 8) 
```
]

.pull-right[

<br><br>

- $Z = f_1(\epsilon_1)$

- $X = x$

- $Y = f_3(Z,X,\epsilon_3)$

]


---

## Interventions

- **_We cannot always carry out the types of interventions we'd like to_**.

  - Ethics
  - Expense
  - Practicality
  
--
  
- In the DAGs framework, we can exploit the structure of the DAG to satisfy particular criteria to make **_identification of a causal quantity possible given observational data_**. 

- Specifically, there are **_two criteria_** (or adjustments) that make identification from empirical data possible. 

  - **_Backdoor Criteria_**
  - **_Frontdoor Criteria_**

---

## Backdoor Adjustment

A set of variables is said to satisfy the backdoor criterion relative to the treatment and outcome variables if that set of variables _blocks every path_ (d-separates) between the treatment and outcome variable. 


```{r,echo=F,fig.width=7,fig.height=4,fig.align='center',dpi=200}
coords <- data.frame(matrix(c("X",0,0,
                              "Y",2,0,
                              "Q",1,1,
                              "G",0,1,
                              "V",0,2,
                              "H",2,2,
                              "Z",2,1), nrow=8, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")


# Initialize the DAG.
dag <- dagify(Y ~ Z, 
              Y ~ Q,
              Z ~ H,
              G ~ V,
              Q ~ H, Q ~ V,
              X ~ G, X ~ Q,
              Y ~ X,
              exposure = "X",
              outcome = "Y",
              coords=coords)

# Plot the DAG
ggdag(dag)
```

---

## Backdoor Adjustment

```{r,echo=F,fig.width=8,fig.height=5.5,fig.align='center',dpi=200}
ggdag_adjustment_set(dag) +
  labs(color="",shape="") +
  scale_color_manual(values=c("steelblue","black")) +
  theme(legend.position = "none")
```

---

```{r}
v <- rnorm(N)
h <- rnorm(N)
z <- h + rnorm(N)
g <- v + rnorm(N)
q <- v + h + rnorm(N)
x <- g + q + rnorm(N)
y <- -2*x + q + rnorm(N)

lm(y ~ x) %>% broom::tidy() # Simple model
```


```{r}
lm(y ~ x + g + q) %>% broom::tidy() 
```

---

![:space 5]

```{r}
lm(y ~ x + v + q) %>% broom::tidy() %>% filter(term=="x")
```

```{r}
lm(y ~ x + h + q) %>% broom::tidy() %>% filter(term=="x")
```

```{r}
lm(y ~ x + z + q) %>% broom::tidy() %>% filter(term=="x")
```

---

## Backdoor Criteria

![:space 1]

Things to note:

- It's necessary to condition on all variables, the Backdoor Criteria offers us the tools to find a **_minimal subset_** of control variables. 

- Using all variables in your data as controls (i.e., a "kitchen sink" model) can lead to **_spurious correlations_** (via collider bias).

- Identifying the variables necessary to satisfy the Backdoor Criteria can **_ease data collection_** efforts. 

- Save **_degrees of freedom_** when modeling. 

- Once we have a backdoor admissible adjustment, we can **_apply any conventional estimator_** to estimate the causal quantity. 

---

## Frontdoor Adjustment

This strategy doesn't rely on closing all backdoor connections. 

Rather, it relies on the existence of **_intermediate variables_** that lie on the causal path from $X$ leading to $Y$.

![:space 5]

```{r,echo=F,fig.width=9.5,fig.height=3.5,fig.align='center',dpi=200}

coords <- data.frame(matrix(c("X",0,0,
                              "Y",2,0,
                              "U",1,1,
                              "Z",1,0), nrow=4, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")


# Initialize the DAG.
dag <- dagify(Y ~ Z, 
              Y ~ U,
              X ~ U,
              Z ~ X,
              exposure = "X",
              outcome = "Y",
              coords=coords)

# Plot the DAG
dag %>% 
  tidy_dagitty() %>% 
  mutate(observed = ifelse(name=="U",2,1)) %>% 
  mutate(observed_text = ifelse(name=="U","black","white")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed)) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F) +
  scale_color_manual(values=c('1'="black",'2'="grey80")) +
  geom_dag_text(size = 8) +
  theme_dag()
```

---

## Frontdoor Adjustment

A set of variables is said to satisfy the frontdoor criterion if

1. $Z$ intercepts all directed paths from $X$ to $Y$

2. There is no unblocked path from $X$ to $Z$

3. All backdoor paths from $Z$ to $Y$ are blocked by $X$

```{r,echo=F,fig.width=9.5,fig.height=3.5,fig.align='center',dpi=200}

coords <- data.frame(matrix(c("X",0,0,
                              "Y",2,0,
                              "U",1,1,
                              "Z",1,0), nrow=4, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")


# Initialize the DAG.
dag <- dagify(Y ~ Z, 
              Y ~ U,
              X ~ U,
              Z ~ X,
              exposure = "X",
              outcome = "Y",
              coords=coords)

# Plot the DAG
dag %>% 
  tidy_dagitty() %>% 
  mutate(observed = ifelse(name=="U",2,1)) %>% 
  mutate(observed_text = ifelse(name=="U","black","white")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed)) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F) +
  scale_color_manual(values=c('1'="black",'2'="grey80")) +
  geom_dag_text(size = 8) +
  theme_dag()
```

---

## Frontdoor Adjustment

We essentially find the effect of $X \rightarrow Z$ and multiply it with the effect of $Z \rightarrow Y$, yielding the indirect effect of $X$ on $Y$  (mediated by $Z$) 

![:space 5]

```{r,echo=F,fig.width=9.5,fig.height=4,fig.align='center',dpi=200}
dag %>% 
  tidy_dagitty() %>% 
  mutate(observed = ifelse(name=="U",2,1)) %>% 
  mutate(observed_text = ifelse(name=="U","black","white")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed)) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F) +
  scale_color_manual(values=c('1'="black",'2'="grey80")) +
  geom_dag_text(size = 8) +
  theme_dag()
```

---

```{r}
set.seed(1234)
N = 1000
u <- rnorm(N)
x <- u + rnorm(N)
z <- .2*x + .6*rnorm(N)
y <- .5*z + .1*u + .4*rnorm(N)

# True Indirect Effect: .2 * .5 = .1
```

```{r}
lm(y ~ x) %>% broom::tidy()
```

```{r}
x_on_z = lm(z ~ x)
z_on_y = lm(y ~ z )
x_on_z$coefficients[2]*z_on_y$coefficients[2]
```


---

## Frontdoor Adjustment

The criterion is violated if $X$ fails to block all paths to $Z$

![:space 6]

```{r,echo=F,fig.width=9.5,fig.height=4,fig.align='center',dpi=200}
coords <- data.frame(matrix(c("X",0,0,
                              "Y",2,0,
                              "U",1,1,
                              "Z",1,0), nrow=4, ncol=3, byrow=T))
colnames(coords) <- c("name","x","y")


# Initialize the DAG.
dag <- dagify(Y ~ Z, 
              Y ~ U,
              X ~ U,
              Z ~ X + U,
              exposure = "X",
              outcome = "Y",
              coords=coords)

# Plot the DAG
dag %>% 
  tidy_dagitty() %>% 
  mutate(observed = ifelse(name=="U",2,1)) %>% 
  mutate(observed_text = ifelse(name=="U","black","white")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed)) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F) +
  scale_color_manual(values=c('1'="black",'2'="grey80")) +
  geom_dag_text(size = 8) +
  theme_dag()
```

---

```{r}
set.seed(1234)
N = 1000
u <- rnorm(N)
x <- u + rnorm(N)
z <- .2*x + .3*u + .3*rnorm(N)
y <- .5*z + .1*u + .4*rnorm(N)

# True Indirect Effect: .2 * .5 = .1
```

```{r}
lm(y ~ x) %>% broom::tidy()
```

```{r}
x_on_z = lm(z ~ x)
z_on_y = lm(y ~ z )
x_on_z$coefficients[2]*z_on_y$coefficients[2]
```


---

## Frontdoor Criterion


- **_Lack of applied examples_** 

  - Only used in "toy models"

  - Lacks substantive examples of when it worked as a valid identification strategy.
  
  - Just because it hasn't been done, doesn't mean it can't ever be done.

- **_Difficult to satisfy assumptions_**
  
  - Hard sell &rarr;"Moreover, an unobserved variable U affecting both X and Y must have no direct effect on Z. Situations where this could be assumed with any confidence seem likely to be exceptional.” (Cox and Wermuth, 1995, p. 689).

---

### Example (1): College Educ. on Earnings Potential

![:space 3]

```{r,echo=F,fig.align="center",fig.width=10,fig.height=5,dpi=200}
wage_coords <- 
  c("background",0,0,
    "p_educ",0,1,
    "college",1,0,
    "family_income",1,1,
    "earnings",2,.5) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}

wage_dag <- dagify(family_income ~ p_educ, 
                   college ~ p_educ + family_income + background,
                   p_educ ~ background,
                   earnings ~ college + family_income,
                   exposure = "college",
                   outcome = "wage",
                   coords = wage_coords)

wage_dag %>% 
  tidy_dagitty(seed = 333,circular = FALSE) %>%
  mutate(observed = ifelse(name=="background",2,1)) %>% 
  mutate(observed_text = ifelse(name=="background","black","grey70")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed),curvature = 1) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F,size=3) +
  scale_color_manual(values=c('1'="black",'2'="grey70")) +
  geom_dag_text(color="black",size=7,nudge_x = 0,nudge_y = .2) +
  theme_dag()
```

---

### Example (1): College Educ. on Earnings Potential

![:space 3]

```{r,echo=F,fig.align="center",fig.width=10,fig.height=5,dpi=200}
wage_coords <- 
  c("background",0,0,
    "p_educ",0,1,
    "college",1,0,
    "family_income",1,1,
    "earnings",2,.5) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}

wage_dag <- dagify(family_income ~ p_educ, 
                   college ~ p_educ + background,
                   p_educ ~ background,
                   earnings ~ college,
                   exposure = "college",
                   outcome = "wage",
                   coords = wage_coords)

wage_dag %>% 
  tidy_dagitty(seed = 333,circular = FALSE) %>%
  mutate(observed = ifelse(name=="background",2,1)) %>% 
  mutate(observed_text = ifelse(name=="background","black","grey70")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed),curvature = 1) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F,size=3) +
  scale_color_manual(values=c('1'="black",'2'="grey70")) +
  geom_dag_text(color="black",size=7,nudge_x = 0,nudge_y = .2) +
  theme_dag()
```

---

### Example (1): College Educ. on Earnings Potential

![:space 3]

```{r,echo=F,fig.align="center",fig.width=10,fig.height=5,dpi=200}
wage_coords <- 
  c("background",0,0,
    "p_educ",0,1,
    "college",1,0,
    "family_income",1,1,
    "earnings",2,.5) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}

wage_dag <- dagify(family_income ~ p_educ, 
                   college ~ p_educ + background,
                   p_educ ~ background,
                   earnings ~ college + background,
                   exposure = "college",
                   outcome = "wage",
                   coords = wage_coords)

wage_dag %>% 
  tidy_dagitty(seed = 333,circular = FALSE) %>%
  mutate(observed = ifelse(name=="background",2,1)) %>% 
  mutate(observed_text = ifelse(name=="background","black","grey70")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed),curvature = 1) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F,size=3) +
  scale_color_manual(values=c('1'="black",'2'="grey70")) +
  geom_dag_text(color="black",size=7,nudge_x = 0,nudge_y = .2) +
  theme_dag()
```

---

### Example (2): Climate and Conflict

```{r,echo=F,fig.align="center",fig.width=10,fig.height=6.5,dpi=200}
conflict_dag <- dagify(agricultural_resources ~ precipitation + pop + development, 
                       conflict ~ agricultural_resources + income,
                       income ~ past_conflict + agricultural_resources + development,
                       precipitation ~ climate,
                       pop ~ climate + past_conflict,
                       development ~ past_conflict,
                   exposure = "precipitation",
                   outcome = "conflict")

conflict_dag %>% 
  tidy_dagitty(seed = 5348,layout = "nicely") %>%
  mutate(observed = ifelse(name=="climate",2,1)) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed),curvature = 1) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F,size=3) +
  scale_color_manual(values=c('1'="black",'2'="grey70")) +
  geom_dag_text(color="black",size=7,nudge_x = -0.1,nudge_y = .2) +
  theme_dag()
```


---

### Example (2): Climate and Conflict

```{r,echo=F,fig.align="center",fig.width=10,fig.height=6.5,dpi=200}
conflict_coords = conflict_dag %>% 
  tidy_dagitty(seed = 5348,layout = "nicely") %>% 
  select(name,x,y) %>% 
  as.data.frame() %>% 
  unique()


conflict_dag2 <- dagify(agricultural_resources ~ precipitation + development, 
                        conflict ~ agricultural_resources + income,
                        income ~ 
                          agricultural_resources + development,
                        precipitation ~ climate,
                        pop ~ climate,
                        exposure = "precipitation",
                        outcome = "conflict",
                       coords=conflict_coords)
conflict_dag2 %>% 
  tidy_dagitty() %>%
  mutate(observed = ifelse(name=="climate",2,1)) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed),curvature = 1) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F,size=3) +
  scale_color_manual(values=c('1'="black",'2'="grey70")) +
  geom_dag_text(color="black",size=7,nudge_x = -0.1,nudge_y = .2) +
  theme_dag()
```

---

### Example (2): Climate and Conflict

```{r,echo=F,fig.align="center",fig.width=10,fig.height=6.5,dpi=200}
conflict_coords = conflict_dag %>% 
  tidy_dagitty(seed = 5348,layout = "nicely") %>% 
  select(name,x,y) %>% 
  as.data.frame() %>% 
  unique()


conflict_dag2 <- dagify(agricultural_resources ~ precipitation + development + climate, 
                        conflict ~ agricultural_resources + income,
                        income ~ 
                          agricultural_resources + development,
                        precipitation ~ climate,
                        pop ~ climate,
                        exposure = "precipitation",
                        outcome = "conflict",
                       coords=conflict_coords)
conflict_dag2 %>% 
  tidy_dagitty() %>%
  mutate(observed = ifelse(name=="climate",2,1)) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed),curvature = 1) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F,size=3) +
  scale_color_manual(values=c('1'="black",'2'="grey70")) +
  geom_dag_text(color="black",size=7,nudge_x = -0.1,nudge_y = .2) +
  theme_dag()
```


---

## Causal Discovery

- A DAG gives rise to **_testable implications_** based on the d-separation relations implied by the model. 

--

- Remember different type of paths capture different forms of conditional independence (i.e. d-separation relations) that can be detected empirically.

  - **_Chain_**: $X \rightarrow Z \rightarrow  Y$ captures $X \perp\!\!\!\!\perp Y | Z$
  
  - **_Fork_**: $X \leftarrow Z \rightarrow  Y$ captures $X \perp\!\!\!\!\perp Y | Z$
  
  - **_Collider_**: $X \rightarrow Z \leftarrow  Y$ captures $X \perp\!\!\!\!\perp Y$

--

- If the data are _not compatible_ with the implied relations in the DAG, then the **_graph is a poor representation of the data_** and we can discard it and build a new one.

---

## Causal Discovery 

.pull-left[

<br>

```{r,echo=F,fig.align="center",fig.width=4,fig.height=3.5,dpi=200}
dag <- dagify(X ~ Z + U,
              Z ~ P,
              Y ~ Z + U,
              exposure = "X",
              outcome = "Y") 

d = dag %>% tidy_dagitty(seed=123) 

ggdag(d)
```
]
.pull-right[

The graph implies the following conditional independence relationships


- $Y \perp\!\!\!\!\perp X | U, Z$
- $Z \perp\!\!\!\!\perp U$
- $P \perp\!\!\!\!\perp U$
- $Y \perp\!\!\!\!\perp P | Z$
- $X \perp\!\!\!\!\perp P | Z$

]

![:space 10]

Using these rules we can **_empirically distinguish_** colliders from chains and forks (but not chains from forks). 

---

## Causal Discovery 

- **_Causal discovery algorithms_** use the conditional in dependencies observed in the data to construct a DAG. 

- We can learn the **_underlying DAG_** that best represents the data up to some **_"equivalence class"_**. 

--

- **_Assumptions_** we need to make for these algorithms to work:

  - **_Acyclicty_**: the underlying model is acyclic.
  
  - Causal **_Sufficiency_**: There are no hidden/latent variables.
  
  - Causal **_Faithfulness_**: D-separation reveals conditional independence relationship
  
  - **_Linearity_** and Gaussian errors

---

## PC Algorithm

Aims to _infer the causal structure compatible with the data_ (given assumptions). 

Algorithm plays out in **_three steps_**:
  
  1. **_Generate skeleton graph_**: 
      - Generates a complete undirected graph with all potential ties
      - Deletes ties if there if conditionally independent (given some set significance level)
  2. **_Locate"v-structures" in the skeleton graph_** 
      - Considers all triplets ( $i$ &mdash; $j$ &mdash; $k$) where $i$ and $k$ are not adjacent (i.e. connected)
      - Checks if $j$ is a collider
      - Check for consistency across all v-structures.
  3. **_Determine edge orientations_**
      - if a collider, make a call. Else a bidirected edge is inserted (can't differentiate between a fork and a chain)

---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
dag <- dagify(X ~ Z + U,
              Z ~ P,
              Y ~ Z + U,
              exposure = "X",
              outcome = "Y") 

d = dag %>% tidy_dagitty(seed=123) 

d %>% 
ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point(show.legend = F) + 
  geom_dag_text(size=7)
```

---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
coord = d %>% select(name,x,y) %>% distinct() %>% as.data.frame

# One
dagify(X ~~ Z + U + P +Y ,
           Z ~~ U + X + Y+P,
           Y ~~ X + U + Z+P,
           U ~~ Y + X + Z+P,
           P ~~ Y + X + Z+ U,
           exposure = "X",
           outcome = "Y",
           coords=coord) %>% 
  tidy_dagitty() %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(arrow_bidirected = arrow(angle = 0),curvature = 0) +
  geom_dag_point(show.legend = F) + 
  geom_dag_text(size=7)
```

---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
# 2
dagify(X ~~ Z + U ,
           Z ~~ X + Y,
           Y ~~ U + Z,
           U ~~ Y + X,
           Z ~~ P,
           exposure = "X",
           outcome = "Y",
           coords=coord) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(arrow_bidirected = arrow(angle = 0),curvature = 0) +
  geom_dag_point(show.legend = F) + 
  geom_dag_text(size=7)
```

---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
#3
dagify(X ~~ Z + U ,
            Z ~~ X + Y,
            Y ~~ U + Z,
            U ~~ Y + X,
            Z ~~ P,
            exposure = "X",
            outcome = "Y",
            coords=coord) %>% 
tidy_dagitty() %>% 
  mutate(color = ifelse(name %in% c("U","X","Z"),"on","off")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(arrow_bidirected = arrow(angle = 0),curvature = 0) +
  geom_dag_point(aes(color=color),show.legend = F) + 
  geom_dag_text(size=7) +
  scale_color_manual(values=c("black","steelblue"))
```


---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
# 4
dagify(Z ~~ X + Y,
       Y ~~ U + Z,
       U ~~ Y ,
       X ~ U + Z,
       Z ~~ P,
       exposure = "X",
       outcome = "Y",
       coords=coord) %>% 
  tidy_dagitty() %>% 
  mutate(color = ifelse(name %in% c("U","Y","Z"),"on","off")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(arrow_bidirected = arrow(angle = 0),curvature = 0) +
  geom_dag_point(aes(color=color),show.legend = F) + 
  geom_dag_text(size=7) +
  scale_color_manual(values=c("black","steelblue"))
```

---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
# 5
dagify(Z ~~ X + Y,
       Y ~~ U + Z,
       Y ~ U + Z,
       X ~ U + Z,
       Z ~~ P,
       exposure = "X",
       outcome = "Y",
       coords=coord) %>% 
  tidy_dagitty() %>% 
  mutate(color = ifelse(name %in% c("P","X","Z"),"on","off")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(arrow_bidirected = arrow(angle = 0),curvature = 0) +
  geom_dag_point(aes(color=color),show.legend = F) + 
  geom_dag_text(size=7) +
  scale_color_manual(values=c("black","steelblue"))
```

---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
# 6
dagify(Z ~~ X + Y,
       Y ~~ U + Z,
       Y ~ U + Z,
       X ~ U + Z,
       Z ~~ P,
       exposure = "X",
       outcome = "Y",
       coords=coord) %>% 
  tidy_dagitty() %>% 
  mutate(color = ifelse(name %in% c("P","Y","Z"),"on","off")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(arrow_bidirected = arrow(angle = 0),curvature = 0) +
  geom_dag_point(aes(color=color),show.legend = F) + 
  geom_dag_text(size=7) +
  scale_color_manual(values=c("black","steelblue"))
```

---

![:space 5]

```{r,echo=F,fig.align="center",fig.width=6,fig.height=4,dpi=200}
# 7
dagify(Y ~ U + Z,
       X ~ U + Z,
       Z ~~ P,
       exposure = "X",
       outcome = "Y",
       coords=coord) %>% 
  tidy_dagitty() %>% 
  # mutate(color = ifelse(name %in% c("P","Y","Z"),"on","off")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(curvature = 0) +
  geom_dag_point(show.legend = F) + 
  geom_dag_text(size=7) +
  scale_color_manual(values=c("black","steelblue"))
```

---

```{r}
set.seed(123) # Seed
N = 1000 # Sample size

# Variable Relations
p = rnorm(N)
z = p + rnorm(N)
u = rnorm(N)
x = z + u + rnorm(N)
y = z + u + rnorm(N)

d = data.frame(y,x,z,u,p)
head(d,10)
```

---

Packages you'll need to install to run causal discovery algorithms in `R`.

```{r,eval=F}
install.packages("BiocManager")
BiocManager::install("RBGL")
BiocManager::install("graph")
install.packages("pcalg")
```

--

![:space 2]

Set our statistic that we'll use to assess conditional independence. Here we'll use the correlation, which is parametric (linear) statistic.
```{r}
ci_stat <- list(C = cor(d), n = nrow(d))
```

--

![:space 2]

And we'll use a test for conditional independence (Fisher's z-transformation of the partial correlation), provided by the `pcalg` package.

```{r}
ci_test <- pcalg::gaussCItest
```

---

```{r,fig.align="center",fig.width=9,fig.height=6,dpi=200}
skeleton_graph <- pcalg::skeleton(suffStat = ci_stat, 
                                  indepTest = ci_test, 
                                  labels = colnames(d), # node labels
                                  alpha = 0.05) # Significance level
Rgraphviz::plot(skeleton_graph) # Plot the skeleton graph
```

---

```{r,fig.align="center",fig.width=9,fig.height=6,dpi=200}
pc_gauss <- pc(suffStat= ci_stat, 
               indepTest = test, 
               labels = colnames(d), 
               alpha = 0.05)
Rgraphviz::plot(pc_gauss)
```

---

## Other Algorithms

- Greedy Equivalence Search (GES Algorithm) - no hidden and selection variables.

- Fast Causal Inference (FCI Algorithm) - allows for hidden and selection variables.

- Really Fast Causal Inference (RFCI Algorithm) - allows for hidden and selection variables.

- Greedy Interventional Equivalence Search (GIES Algorithm)  - no hidden and selection variables.

- Iterative Deepening Algorithm (IDA) - no hidden and selection variables.

- Generalized Backdoor Criterion - allows for hidden but no selection variables.



---

class: newsection

# Potential Outcomes

---


![:space 13.5]

```{r,echo=F,fig.align="center",fig.width=9,fig.height=6.5,dpi=200}
bind_rows(
  tibble(y=5,x=3,candidate = "You",size=75,alpha=1,color="grey30"),
  # tibble(y=1,x=1,candidate = "Grad School",size=75,alpha=1,color="steelblue"),
  # tibble(y=1,x=5,candidate = "No\nGrad School",size=75,alpha=1,color="darkred"),
  # tibble(y=-3,x=3,candidate = "$$$",size=75,alpha=1,color="grey60"),
) %>% 
  
  ggplot(aes(x,y,size=size,color=color,alpha=alpha)) +
  # geom_segment(x=3,xend=1,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=5,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=1,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=5,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=3,y=5,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_point() +
  scale_color_identity() +
  scale_alpha_identity() +
  scale_size_identity() +
  geom_text(color="white",aes(label=candidate),size=8) +
  ylim(-5,7) + xlim(0,6) +
  theme_void() +
  theme(legend.position = "none")
```

---


![:space 13.5]

```{r,echo=F,fig.align="center",fig.width=9,fig.height=6.5,dpi=200}
bind_rows(
  tibble(y=5,x=3,candidate = "You",size=75,alpha=1,color="grey30"),
  # tibble(y=1,x=1,candidate = "Grad School",size=75,alpha=1,color="steelblue"),
  # tibble(y=1,x=5,candidate = "No\nGrad School",size=75,alpha=1,color="darkred"),
  tibble(y=-3,x=3,candidate = "$$$",size=75,alpha=1,color="grey60"),
) %>% 
  
  ggplot(aes(x,y,size=size,color=color,alpha=alpha)) +
  # geom_segment(x=3,xend=1,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=5,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=1,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=5,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=3,xend=3,y=5,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_point() +
  scale_color_identity() +
  scale_alpha_identity() +
  scale_size_identity() +
  geom_text(color="white",aes(label=candidate),size=8) +
  ylim(-5,7) + xlim(0,6) +
  theme_void() +
  theme(legend.position = "none")
```

---

![:space 5]

Considering school (and intervention/treatment)

```{r,echo=F,fig.align="center",fig.width=9,fig.height=6.5,dpi=200}
bind_rows(
  tibble(y=5,x=3,candidate = "You",size=75,alpha=1,color="grey30"),
  tibble(y=1,x=1,candidate = "Grad School",size=75,alpha=1,color="steelblue"),
  tibble(y=1,x=5,candidate = "No\nGrad School",size=75,alpha=1,color="darkred"),
  tibble(y=-3,x=3,candidate = "$$$",size=75,alpha=1,color="grey60"),
) %>% 
  
  ggplot(aes(x,y,size=size,color=color,alpha=alpha)) +
  geom_segment(x=3,xend=1,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=3,xend=5,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=1,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=5,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=3,y=5,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_point() +
  scale_color_identity() +
  scale_alpha_identity() +
  scale_size_identity() +
  geom_text(color="white",aes(label=candidate),size=8) +
  ylim(-5,7) + xlim(0,6) +
  theme_void() +
  theme(legend.position = "none")
```


---


![:space 4]

Can only observe **_one outcome_**

```{r,echo=F,fig.align="center",fig.width=9,fig.height=6.5,dpi=200}
bind_rows(
  tibble(y=5,x=3,candidate = "You",size=75,alpha=1,color="grey30"),
  tibble(y=1,x=1,candidate = "Grad School",size=75,alpha=1,color="steelblue"),
  # tibble(y=1,x=5,candidate = "No\nGrad School",size=75,alpha=1,color="darkred"),
  tibble(y=-3,x=3,candidate = "$$$",size=75,alpha=1,color="grey60"),
) %>% 
  
  ggplot(aes(x,y,size=size,color=color,alpha=alpha)) +
  geom_segment(x=3,xend=1,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=1,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=5,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=5,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=3,y=5,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_point() +
  scale_color_identity() +
  scale_alpha_identity() +
  scale_size_identity() +
  geom_text(color="white",aes(label=candidate),size=8) +
  ylim(-5,7) + xlim(0,6) +
  theme_void() +
  theme(legend.position = "none")
```

---


![:space 4]

Cannot observe the **_counter-factual_**

```{r,echo=F,fig.align="center",fig.width=9,fig.height=6.5,dpi=200}
bind_rows(
  tibble(y=5,x=3,candidate = "You",size=75,alpha=1,color="grey30"),
  # tibble(y=1,x=1,candidate = "Grad School",size=75,alpha=1,color="steelblue"),
  tibble(y=1,x=5,candidate = "No\nGrad School",size=75,alpha=1,color="darkred"),
  tibble(y=-3,x=3,candidate = "$$$",size=75,alpha=1,color="grey60"),
) %>% 
  
  ggplot(aes(x,y,size=size,color=color,alpha=alpha)) +
  # geom_segment(x=3,xend=1,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=1,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=3,xend=5,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=5,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=3,y=5,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_point() +
  scale_color_identity() +
  scale_alpha_identity() +
  scale_size_identity() +
  geom_text(color="white",aes(label=candidate),size=8) +
  ylim(-5,7) + xlim(0,6) +
  theme_void() +
  theme(legend.position = "none")
```

---

![:space 4]

.center[
**The Fundamental Problem of Causal Inference**
]

```{r,echo=F,fig.align="center",fig.width=9,fig.height=6.5,dpi=200}
bind_rows(
  tibble(y=5,x=3,candidate = "You",size=75,alpha=1,color="grey30"),
  tibble(y=1,x=1,candidate = "Grad School",size=75,alpha=1,color="steelblue"),
  tibble(y=1,x=5,candidate = "No\nGrad School",size=75,alpha=1,color="darkred"),
  tibble(y=-3,x=3,candidate = "$$$",size=75,alpha=1,color="grey60"),
) %>% 
  
  ggplot(aes(x,y,size=size,color=color,alpha=alpha)) +
  geom_segment(x=3,xend=1,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=1,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=3,xend=5,y=5,yend=1,size=.5,alpha=.2,color="grey40") +
  geom_segment(x=5,xend=3,y=1,yend=-3,size=.5,alpha=.2,color="grey40") +
  # geom_segment(x=3,xend=3,y=5,yend=-3,size=.5,alpha=.2,color="grey40") +
  geom_point() +
  scale_color_identity() +
  scale_alpha_identity() +
  scale_size_identity() +
  geom_text(color="white",aes(label=candidate),size=8) +
  ylim(-5,7) + xlim(0,6) +
  theme_void() +
  theme(legend.position = "none")
```


---

## Potential Outcomes

![:space 5]

$$y_i(1) \equiv  y_i(T=1)$$

$$y_i(0) \equiv  y_i(T=0)$$

![:space 2]

--

**Causal Treatment Effect** for unit $i$ 

![:space 1]

$$ TE_i = y_i(1) - y_i(0)$$
![:space 1]

The causal effect is a comparison of the potential outcomes for the _same unit_ at the same moment in time.


---

### Quantities of interest

**_Average Treatment Effect_**

$$ATE = E[y_i(1) - y_i(0)] =\frac{1}{N}\sum_{i=1}^N (y_i(1) - y_i(0))$$
![:space 1]

--

**_Average Treatment Effect for the Treated Group_**

![:space 1]

$$ATT = E[y_i(1)|T=1] - E[y_i(0)|T=1]$$

![:space 1]

--

**_Average Treatment Effect for the Control Group_**

![:space 1]

$$ATU = E[y_i(1)|T=0] - E[y_i(0)|T=0]$$

---

## Potential Outcomes


**_Fundamental Problem of Causal Inference_** is that we can only observe one state


At its core, the potential outcomes framework treats causal identification as a **_missing data problem_**:  _Given any treatment assigned to an individual unit, the potential outcome associated with any alternate treatment is missing._


$$ TE_i =  y_i(1) - y_i(0)$$


$$ TE_i =  y_i(1) - \color{lightgrey}{y_i(0)}$$


$$ TE_i =  \text{observed} - \color{lightgrey}{\text{unobserved}}$$


We must **_rely on multiple units_** to make **_inferences_** about the causal quantity (effect).

---

![:space 10]

.center[

```{r,echo=FALSE}
D = tribble(
  ~Patients, ~y_1,~y_0,~TE,
  1,7,1,6,
  2,5,6,-1,
  3,5,1,4,
  4,7,8,-1,
  5,4,2,2,
  6,10,1,9,
  7,1,10,-9,
  8,5,6,-1,
  9,3,7,-4,
  10,9,8,1,
) 

D %>% kableExtra::kable(., "html", booktabs = T,align = c('c','c','c','c'),
                        caption = "Cunningham 2018") %>% 
  kableExtra::kable_styling(latex_options = c("striped",
                                  "scale_down","repeat_header"),
                full_width = T,font_size = 20) 
```
]

```{r}
cat("ATE =",mean(D$y_1 - D$y_0))
```


---

![:space 10]

.center[

```{r,echo=FALSE}
D_obs = tribble(
  ~Patients, ~y,~T,
  1,7,1,
  2,6,0,
  3,5,1,
  4,8,0,
  5,4,1,
  6,10,1,
  7,10,0,
  8,6,0,
  9,7,0,
  10,9,1,
) 

D_obs %>% kableExtra::kable(., "html", booktabs = T,align = c('c','c','c','c'),
                        caption = "Cunningham 2018") %>% 
  kableExtra::kable_styling(latex_options = c("striped",
                                  "scale_down","repeat_header"),
                full_width = T,font_size = 20) 
```
]


![:space 2]

In this example, patients are assigned to the treatment _if it gives them a better outcome_.

---

![:space 10]

We can estimate the ATE by comparing the **_difference in mean outcomes_** across the treatment and control group, containing _many similar individuals_.

![:space 5]

$$ E[y_i|T_i=1] - E[y_i|T_i=0] $$
![:space 5]

--

```{r}
cat("(observed) ATE =",
    mean(D_obs$y[D_obs$T==1]) - mean(D_obs$y[D_obs$T==0]))
```

![:space 5]

Our estimate for the ATE in the observed data is way off from the true ATE (.6). Why? 

---

![:space 3]

An issue emerges when the **_assignment mechanism_** (i.e. how units get into the treatment or control groups) **_depends on the outcome_**.

![:space 3]

Such non-randomness generates: **_selection** and **_heterogeneous treatment effect bias_**. 

```{r,echo=F,fig.align="center",fig.width=9,fig.height=3.5,dpi=200}
coords <- 
  c("T",0,0,
    "A",1,1,
    "Y",2,0) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}


# Initialize the DAG.
dag <- dagify(Y ~ T + A,
              T ~ A,
              exposure = "T",
              outcome = "Y",
              coords=coords)


dag %>% 
  tidy_dagitty() %>% 
  mutate(observed = ifelse(name=="U",2,1)) %>% 
  mutate(observed_text = ifelse(name=="U","black","white")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed)) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F) +
  scale_color_manual(values=c('1'="black",'2'="grey80")) +
  geom_dag_text(size = 8) +
  theme_dag()
```


---

![:space 3]

An issue emerges when the **_assignment mechanism_** (i.e. how units get into the treatment or control groups) **_depends on the outcome_**.

A **_random assignment_** mechanism breaks any potential association between non-random unobservables and the outcome. 

$$y_i(1),y_i(0) \perp\!\!\!\!\perp A$$

```{r,echo=F,fig.align="center",fig.width=9,fig.height=3.5,dpi=200}
coords <- 
  c("T",0,0,
    "A",1,1,
    "Y",2,0) %>% 
  {data.frame(matrix(., nrow=length(.), ncol=3, byrow=T))} %>% 
  {colnames(.) <- c("name","x","y");.}


# Initialize the DAG.
dag <- dagify(Y ~ T,
              T ~ A,
              exposure = "T",
              outcome = "Y",
              coords=coords)


dag %>% 
  tidy_dagitty() %>% 
  mutate(observed = ifelse(name=="U",2,1)) %>% 
  mutate(observed_text = ifelse(name=="U","black","white")) %>% 
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_edges(aes(edge_linetype=observed)) +
  geom_dag_point(aes(color=factor(observed)),show.legend = F) +
  scale_color_manual(values=c('1'="black",'2'="grey80")) +
  geom_dag_text(size = 8) +
  theme_dag()
```




---

### Stable Unit Treatment Value Assumption (SUTVA)

> "The potential outcomes for any unit do not vary with the treatments assigned to other units, and, for each unit, there are no different forms or versions of each treatment level, which lead to different potential outcomes." (Imbens and Rubin 2015, pg. 10)

![:space 2]

- **No Interference**
  
  - My being treated doesn't effect your outcome( $y_i$ )
  - "Spillover"

![:space 2]

- **No Hidden Variations of Treatments** 

  - Every treated unit is treated with the same intervention
  

---

### Common Support Assumption

![:space 10]

$$pr(T_i = 1 |X_i) < 1$$

![:space 5]

- It must be conceivable that a treated unit **_could have been assigned_** to the control group.

![:space 5]

- If this doesn't hold, then **_ $y_i(0)$ doesn't even logically exist_**.

---

## Comparing Frameworks

- Both the SCM and PO frameworks **_aim to eliminate confoundedness_**.

- **_Controls_**

  - SCMs differentiate **_confounders from colliders_**, aiding in the selection of [good and bad controls](http://causality.cs.ucla.edu/blog/index.php/2019/08/14/a-crash-course-in-good-and-bad-control/)

  - PO often requires identification strategies **_conditional on controls_** (we'll learn them in the coming weeks). 
  
  - Both methods require careful specification and consideration of the elements in the model necessary for valid identification.
  
- Ultimately, both are **_conceptual frameworks_** for thinking about and formalizing causal identification strategies.